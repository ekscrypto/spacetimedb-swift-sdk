# Converting Rust Module Bindings to Swift Table Row Decoders

This guide explains how to convert SpacetimeDB Rust module bindings to Swift table row decoders for use with the spacetimedb-swift-sdk.

## Table of Contents
- [Prerequisites](#prerequisites)
- [Generating Rust Module Bindings](#generating-rust-module-bindings)
- [Understanding Rust Type Mappings](#understanding-rust-type-mappings)
- [Creating Swift Table Row Decoders](#creating-swift-table-row-decoders)
- [Complete Example: User Table](#complete-example-user-table)
- [Common Patterns](#common-patterns)
- [Troubleshooting](#troubleshooting)

## Prerequisites

1. SpacetimeDB CLI installed ([Installation Guide](https://spacetimedb.com/docs/getting-started#installation))
2. A SpacetimeDB module deployed to a server
3. The spacetimedb-swift-sdk added to your project

## Generating Rust Module Bindings

First, generate the Rust client bindings for your module to understand the data structure:

```bash
# Generate Rust client bindings
spacetimedb generate --lang rust --out-dir client/src --project-path server

# The generated files will be in client/src/module_bindings/
# Each table will have a corresponding _type.rs file
```

The generated files provide the exact structure and types for each table in your module.

## Understanding Rust Type Mappings

When converting from Rust to Swift, use these type mappings:

| Rust Type | Swift Type | BSATN AlgebraicValueType |
|-----------|------------|--------------------------|
| `u8` | `UInt8` | `.uint8` |
| `u16` | `UInt16` | `.uint16` |
| `u32` | `UInt32` | `.uint32` |
| `u64` | `UInt64` | `.uint64` |
| `u128` | `UInt128` | `.uint128` |
| `u256` / `Identity` | `UInt256` | `.uint256` |
| `i8` | `Int8` | `.int8` |
| `i16` | `Int16` | `.int16` |
| `i32` | `Int32` | `.int32` |
| `i64` | `Int64` | `.int64` |
| `i128` | `Int128` | `.int128` |
| `i256` | `Int256` | `.int256` |
| `f32` | `Float` | `.float32` |
| `f64` | `Double` | `.float64` |
| `bool` | `Bool` | `.bool` |
| `String` | `String` | `.string` |
| `Vec<u8>` | `Data` | `.bytes` |
| `Vec<T>` | `[T]` | `.array(elementType)` |
| `Option<T>` | `T?` | `.sum(OptionModel(T))` |
| `struct` | `struct` | `.product(fields)` |

### Important: Option Types

SpacetimeDB represents `Option<T>` as a sum type with two variants:
- Tag 0: `Some(value)` - contains the value
- Tag 1: `None` - no value

## Creating Swift Table Row Decoders

Every Swift table row decoder needs three components:

### 1. The Row Structure

Define a struct that matches the table structure:

```swift
struct YourTableRow {
    // Properties matching the table columns
}
```

### 2. The Model Definition

Create a `ProductModel` that describes the BSATN structure:

```swift
struct Model: ProductModel {
    var definition: [AlgebraicValueType] {
        // Array of types matching the table columns in order
    }
}
```

### 3. The Decoder

Implement the `TableRowDecoder` protocol:

```swift
struct YourTableRowDecoder: TableRowDecoder {
    var model: ProductModel { YourTableRow.Model() }
    func decode(modelValues: [AlgebraicValue]) throws -> Any { 
        try YourTableRow(modelValues: modelValues) 
    }
}
```

## Complete Example: User Table

Let's convert a real example from the quickstart-chat module.

### Rust Module Binding (user_type.rs)

```rust
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB
#[derive(Serialize, Deserialize, Clone, PartialEq, Debug)]
pub struct User {
    pub identity: Identity,      // UInt256 in BSATN
    pub name: Option<String>,    // Optional string
    pub online: bool,            // Boolean
}
```

### Swift Table Row Decoder (UserRow.swift)

```swift
import Foundation
import BSATN
import SpacetimeDB

/// Represents a user row from the user table
struct UserRow {
    let identity: UInt256  // Maps from Identity
    let name: String?      // Maps from Option<String>
    let online: Bool       // Maps from bool
    
    // Define the sum model for optional types
    struct OptionalStringSumModel: SumModel {
        static var size: UInt32 { 2 }  // 2 variants: Some(0) or None(1)
    }
    
    // Define the product model matching the table structure
    struct Model: ProductModel {
        var definition: [AlgebraicValueType] { [
            .uint256,                         // identity field
            .sum(OptionalStringSumModel()),  // optional name field
            .bool                             // online field
        ]}
    }
    
    // Initialize from model values (used by the decoder)
    init(modelValues: [AlgebraicValue]) throws {
        let model = Model()
        guard modelValues.count == model.definition.count else {
            throw BSATNError.invalidStructure("Invalid UserRow structure")
        }
        
        // Extract identity
        guard case .uint256(let identity) = modelValues[0] else {
            throw BSATNError.invalidStructure("Expected UInt256 for identity")
        }
        self.identity = identity
        
        // Extract optional name (sum type handling)
        switch modelValues[1] {
        case .sum(tag: 0, value: let data):
            // Some case - decode the string from data
            let reader = BSATNReader(data: data)
            let nameValue = try reader.readAlgebraicValue(as: .string)
            guard case .string(let name) = nameValue else {
                throw BSATNError.invalidStructure("Expected string for name")
            }
            self.name = name.isEmpty ? nil : name
            
        case .sum(tag: 1, value: _):
            // None case
            self.name = nil
            
        default:
            throw BSATNError.invalidStructure("Expected sum type for optional name")
        }
        
        // Extract online status
        guard case .bool(let online) = modelValues[2] else {
            throw BSATNError.invalidStructure("Expected bool for online")
        }
        self.online = online
    }
    
    // Alternative: Direct reader initialization (more efficient)
    init(reader: BSATNReader) throws {
        self.identity = try reader.read()
        self.name = try reader.readOptional { try reader.readString() }
        self.online = try reader.read()
    }
}

// The decoder implementation
struct UserRowDecoder: TableRowDecoder {
    var model: ProductModel { UserRow.Model() }
    
    func decode(modelValues: [AlgebraicValue]) throws -> Any { 
        try UserRow(modelValues: modelValues) 
    }
}
```

### Registering the Decoder

Register your decoder before connecting to the database:

```swift
let client = try SpacetimeDBClient(
    host: "http://localhost:3000",
    db: "your-module"
)

// Register the decoder for the "user" table
await client.registerTableRowDecoder(
    table: "user", 
    decoder: UserRowDecoder()
)

// Connect and subscribe
try await client.connect(token: savedToken, delegate: myDelegate)
```

## Common Patterns

### Handling Nested Structs

For tables with nested struct fields:

```rust
// Rust
pub struct Player {
    pub id: u64,
    pub position: Position,
}

pub struct Position {
    pub x: f32,
    pub y: f32,
}
```

```swift
// Swift
struct PositionModel: ProductModel {
    var definition: [AlgebraicValueType] { [.float32, .float32] }
}

struct PlayerRow {
    let id: UInt64
    let position: Position
    
    struct Position {
        let x: Float
        let y: Float
    }
    
    struct Model: ProductModel {
        var definition: [AlgebraicValueType] { [
            .uint64,
            .product(PositionModel())
        ]}
    }
}
```

### Handling Enums

For Rust enums (sum types):

```rust
// Rust
pub enum Status {
    Active,
    Inactive,
    Banned(String),
}
```

```swift
// Swift
enum Status {
    case active      // tag 0
    case inactive    // tag 1
    case banned(String)  // tag 2 with associated value
    
    init(from value: AlgebraicValue) throws {
        guard case .sum(tag: let tag, value: let data) = value else {
            throw BSATNError.invalidStructure("Expected sum type")
        }
        
        switch tag {
        case 0: self = .active
        case 1: self = .inactive
        case 2:
            let reader = BSATNReader(data: data)
            let reason = try reader.readString()
            self = .banned(reason)
        default:
            throw BSATNError.invalidStructure("Unknown status tag")
        }
    }
}
```

### Handling Arrays

For array fields:

```rust
// Rust
pub struct Message {
    pub id: u64,
    pub tags: Vec<String>,
}
```

```swift
// Swift
struct MessageRow {
    let id: UInt64
    let tags: [String]
    
    struct Model: ProductModel {
        var definition: [AlgebraicValueType] { [
            .uint64,
            .array(.string)
        ]}
    }
}
```

## Troubleshooting

### Common Issues

1. **"Invalid structure" errors**: Ensure your model definition matches the exact order and types of the Rust struct fields.

2. **Optional handling errors**: Remember that SpacetimeDB uses sum types for optionals:
   - Tag 0 = Some(value)
   - Tag 1 = None

3. **Identity type confusion**: SpacetimeDB's `Identity` type maps to `UInt256` in Swift.

4. **Missing decoder registration**: Always register decoders before connecting:
   ```swift
   await client.registerTableRowDecoder(table: "table_name", decoder: YourDecoder())
   ```

### Debugging Tips

1. Enable debug mode to see BSATN parsing details:
   ```swift
   let client = try SpacetimeDBClient(
       host: "...",
       db: "...",
       debugEnabled: true  // Shows detailed parsing info
   )
   ```

2. Check the generated Rust bindings for the exact field order and types.

3. Use the `onIncomingMessage` delegate callback to inspect raw message bytes.

## Related Documentation

- [SpacetimeDB Getting Started](https://spacetimedb.com/docs/getting-started)
- [SpacetimeDB Rust Module Quickstart](https://spacetimedb.com/docs/modules/rust/quickstart)
- [SpacetimeDB TypeScript Client Tutorial](https://spacetimedb.com/docs/sdks/typescript/quickstart)
- [BSATN Format Specification](https://spacetimedb.com/docs/bsatn)

## Next Steps

After creating your decoders:

1. Implement the `SpacetimeDBClientDelegate` to handle table updates
2. Subscribe to your tables using SQL queries
3. Call reducers to modify data
4. Handle connection lifecycle events

For a complete example, see the [quickstart-chat](Sources/quickstart-chat) implementation in this repository.